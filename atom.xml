<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zone</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-12-12T14:29:27.019Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Kegard</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java</title>
    <link href="http://example.com/2023/12/12/Java/"/>
    <id>http://example.com/2023/12/12/Java/</id>
    <published>2023-12-12T14:16:30.000Z</published>
    <updated>2023-12-12T14:29:27.019Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>​由于面临找工作困境，结合大环境和自身分析，暂定目标岗位为<code>java</code>后端开发，因此快速学习一下<code>java</code>基础语法。</p><h3 id="基础语法">基础语法</h3><ol type="1"><li>数据类型包括基本数据类型和引用数据类型，强制转换使用小括号</li><li>引用数据类型就是可以被引用的数据类型，包括字符串、</li></ol><h3 id="面对对象">面对对象</h3><h4 id="内存">内存</h4><ol type="1"><li>Java中的存储空间，栈中间储存函数和变量，堆中储存对象，元空间储存类的信息。</li><li>堆中保存的是实例对象的成员属性，元空间中储存的是类的静态属性。</li><li>先有类再有对象，因此成员函数中可以调用静态函数，但是静态函数不允许调用成员函数</li><li>类的信息加载完成后，会自动调用静态代码块，可以完成静态属性的初始化功能</li></ol><h4 id="包">包</h4><ol type="1"><li>包，容纳类，主要用于功能分类，包含上下级关系</li><li>创建对象时，可以使用类的相对路径来准确调用</li></ol><h4 id="继承与多态">继承与多态</h4><ol type="1"><li>继承 Extends</li><li>类的继承只能单继承，只能有一个父类，不能有多个父类</li><li>super和this 分别表示调用父类的成员变量和子类的成员变量</li><li>对于一个父类，创建子类n次，那么父类也需要相对应的创建n次，每个不同的子类对应的父类对象不一样</li><li>多态，一个对象在不同场景下表现出来的不同状态，但是对使用场景进行了约束</li></ol><h4 id="重写与重载">重写与重载</h4><ol type="1"><li>方法名相同、参数列表不相同，会认为是不同的方法，这就是重载</li><li>如果子类对象需要在特殊场合使用父类方法，那么就需要重写方法，重写要求子类和父类的方法名字相同，返回值类型相同，参数列表相同。</li></ol><h4 id="枚举">枚举</h4><ol type="1"><li>枚举是特殊的类，包含特定对象，且对象不会改变，使用关键字<code>enum</code>，对象一般是用大写标识符</li><li>枚举可以使用构造函数进行构造，枚举类会将对象放置在对前面</li><li>枚举类不能创建对象，他的对象是在内部自行创建</li></ol><h4 id="匿名类">匿名类</h4><ol type="1"><li>匿名类，在一些场合，类的名字不重要，主要是使用类的方法或者功能，因此可以使用匿名类，</li><li>使用匿名类，减少重复操作，接口也可以使用匿名类，具体实现就是在创建对象的时候直接实现抽象类中的方法即可</li><li>Bean类的设计规范，必须含有无参、公共的构造方法，属性必须私有化，然后提供公共的set、get方法</li></ol><h3 id="常见类和对象">常见类和对象</h3><h4 id="object">Object</h4><ol type="1"><li><p><code>toString()</code>默认打印对象的内存地址，输出的是十六进制，也可以使用<code>hashCode()</code>,输出结果十进制</p></li><li><p><code>equals()</code>判断两个对象是否相等，比较对象的时候，默认比较的是内容地址</p></li><li><p><code>getSimplename()</code> 获取对象的类型信息</p></li></ol><h4 id="数组">数组</h4><ol type="1"><li><类型> [] <名称>= new <类型>[size] ;</li><li><code>Boolean</code> 类型数组默认值是<code>false</code>，<code>Object</code>数组和字符串数组默认值是<code>NULL</code></li><li><code>java</code>中按值传递指的是在调用参数的时候，将实际参数复制一份传递到函数中，这样在函数中对参数进行修改，不会影响到原来的实际参数</li><li>引用传递指的是将实际参数的地址直接传递到函数中，函数对参数的修改会影响原来的实际参数</li><li>一般来说，对于基础数据类型变量，使用按值传递，对于对象变量，使用的是引用传递。但是实际上二者本质相同，区别就是基础数据类型变量的值是数字和布尔值，而对象引用变量的值是对象的地址。</li></ol><h4 id="字符串">字符串</h4><ol type="1"><li><p>字符串是连续的字符组成的整体</p></li><li><p>字符可以使用<code>ASCII</code>码来表示字符，<code>ASCII</code>码使用一个字节表示。</p></li><li><p><code>java</code>使用new构造字符串和直接赋值字符串的方式在底层实现不同。</p></li><li><p>连续的字符数组可以转换为字符串</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">cs</span> <span class="operator">=</span>&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;b&#x27;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cs);</span><br></pre></td></tr></table></figure></li><li><p>字符串拼接相当于创建新的字符串，并且新的字符串与原来的字符串内存地址不一样。</p></li><li><p>字符串的比较，采用Object中比较的成员方法<code>a.equals(b)</code></p></li><li><p>字符串的截取，<code>s.substr(straIndex,endIndex)</code>,不包含最后的索引</p></li><li><p>字符串的截取，<code>s.split()</code></p></li><li><p>字符串的去空格，<code>s.strim()</code>,去除字符串的首尾空格</p></li><li><p>字符串的替换，<code>s.replace()</code>或者<code>s.replaceAll()</code></p></li><li><p>字符串的大小写转换 <code>s.toLowerCase()</code> 或者<code>s.toUpperCase()</code></p></li><li><p>字符串的查找 <code>s.charAt(i);</code></p></li><li><p>使用<code>StringBuilder</code>对字符串进行拼接，本质上是使用底层数组完成字符串的拼接</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;++i)&#123;</span><br><span class="line">           s.append(i);</span><br><span class="line">       &#125;</span><br><span class="line">System.out.println(s.toString());</span><br></pre></td></tr></table></figure></li></ol><h4 id="引用数据类型">引用数据类型</h4><ol type="1"><li>内置的八种数据类型<code>byte、short、int、long、float、double、char、boolean</code>并没有对应的属性和方法，因此可以将其进行扩展，使用包装类来实现更多的功能。</li><li>自动装箱和自动拆箱</li><li>日期类与日历类的使用</li><li>工具类不应该创建对象才能使用，这也就意味着可以直接使用类中的属性和方法，一般都声明为静态的</li><li>工具类对外提供的属性或者方法都应该是公共的</li><li><code>hashcode()</code>主要是获得对象散列地址，并非实际的内存地址，因此<code>hashcode()</code>相等无法证明两个对象为同一个对象，因此使用<code>System.identityHashCode()</code>查看实际的内存地址</li><li><code>Integer</code>类中提前将（-128，127）储存到<code>caffe</code>中，因此当数值相同时，即使对象不同，其内存地址也是相等的</li><li>对于引用类型的比较，都需要使用<code>equals()</code>进行比较，使用<code>==</code>比较的是对象的内存地址</li></ol><h3 id="异常">异常</h3><ol type="1"><li><p>异常分为两类，可以通过代码恢复正常逻辑执行的异常(运行期异常)、不能通过恢复代码恢复的异常（编译器异常）,前者是<code>RuntimeException()</code>,后者是<code>Exception()</code></p></li><li><p>错误不是异常，是与异常并列的。<code>Error()</code></p></li><li><p>异常处理语法,和<code>swich（）</code>比较相似</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//可能会出现的异常的代码</span></span><br><span class="line">    <span class="comment">//如果出现异常，那么JVM会将异常进行封装，形成一个具体的异常类，然后将这个异常抛出</span></span><br><span class="line">    <span class="comment">//所有异常对象都可以被抛出</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(<span class="comment">/*抛出的异常对象，对象引用*/</span>)&#123;</span><br><span class="line"><span class="comment">//异常的解决方案</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//最终执行的代码逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果方法中可能会出现问题，那么需要提前声明，此时就需要关键字throws。如果需要手动抛出异常对象，那么需要使用throw关键字，然后new出异常</p></li></ol><p>​</p><h3 id="集合">集合</h3><ol type="1"><li>集合可以分为单一数据体系和成对出现的数据体系</li><li>Collection接口中常用的子接口包括<code>List、Set、Queue</code>，其中<code>List</code>的具体实现包括<code>ArrayList</code>和<code>Linked List</code>,Set的具体实现类包括<code>Hashset</code>，<code>Queuen</code>的具体实现类包括<code>ArrayBlockingQueue</code></li><li>Map接口中常用的具体实现包括<code>HashMap</code>和<code>HashTable</code></li></ol><h4 id="arraylist"><code>ArrayList</code></h4><ol type="1"><li>增加数据 <code>add(value)</code></li><li>获取指定位置的数据，采用索引方式 <code>get(index)</code></li><li>修改指定位置数据 <code>set(index,value)</code></li><li>删除数据 <code>remove(index)</code></li><li>扩容机制：<code>ArrayList</code>底层是数组实现，扩容可以分为两种情况<ol type="1"><li>当<code>ArrayList</code>容量是0的时候，此时添加元素需要扩容，不同的构造方法对应不同的扩容策略：<ol type="1"><li>无参构造，创建<code>ArrayList</code>后容量为0，添加第一个元素后，容量变为10，此后若需要扩容，则正常扩容。</li><li>传容量构造，当参数为0时，创建<code>ArrayList</code>后容量为0，添加第一个元素后，容量为1，此时<code>ArrayList</code>是满的，下次添加元素时需正常扩容。</li><li>传列表构造，当列表为空时，创建<code>ArrayList</code>后容量为0，添加第一个元素后，容量为1，此时<code>ArrayList</code>是满的，下次添加元素时需正常扩容。</li></ol></li><li>当<code>ArrayList</code>的容量大于0，并且<code>ArrayList</code>是满的时，此时添加元素的话，进行正常扩容，每次扩容到原来的1.5倍。</li></ol></li><li>插入参数 <code>add(index,value)</code></li><li>添加集合 <code>add(list)</code></li><li>获取数据在数据中的索引号 <code>indexOf(value)</code></li></ol><h4 id="linkedlist"><code>LinkedList</code></h4><ol type="1"><li>添加元素 <code>add()</code></li><li>在头部添加元素 <code>addFirst()</code></li><li>在尾部添加元素 <code>addLast()</code></li></ol><h4 id="泛型">泛型</h4><ol type="1"><li><p>用于约束外部对象的使用场景，就是类型；用于约束内部对象的使用场景，就是泛型。</p></li><li><p>泛型基础语法</p></li><li><p>比较器其实也使用了泛型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1,Integer o2)</span>&#123;</span><br><span class="line"><span class="comment">// 如果第一个数比第二个数大，那么返回结果为正数，表示升序</span></span><br><span class="line">    <span class="keyword">return</span> o1-o2;</span><br><span class="line"><span class="comment">// 如果第一个数比第二个数小，那么返回结果为负数，表示降序</span></span><br><span class="line">    <span class="keyword">return</span> o2-o1;</span><br><span class="line"><span class="comment">//如果第一个数与第二个数一样大，那么返回零，</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="hashset"><code>HashSet</code></h4><ol type="1"><li>增加数据 <code>add(value)</code></li><li>删除数据 <code>remove(value)</code></li><li>查询数据 <code>set只能遍历查询</code></li><li>转换为数组 <code>toArray()</code></li><li>清空元素 <code>clear()</code></li><li><code>HashSet</code>判断元素不同的标准：<code>HashCode</code>不同，所以即使对象的属性相同，<code>Hashcode</code>不同，<code>HashSet</code>会认为其是两个元素。</li><li><code>HashSet</code>底层数据是数组+链表，</li></ol><h4 id="queue"><code>Queue</code></h4><ol type="1"><li><code>ArrayBlockingQueue</code> 数组+阻塞队列</li><li>添加元素 <code>add()</code> 当超过容量之后，会直接报错</li><li>添加元素 <code>put()</code>超过容量之后，会直接堵塞，程序不会继续运行</li><li>添加元素 <code>offer()</code></li><li>抛出元素 <code>poll（）</code></li></ol><h4 id="hashmap"><code>HashMap</code></h4><ol type="1"><li>添加数据 <code>put(k,v)</code></li><li>查询数据 <code>get(k)</code></li><li>删除数据 <code>remove(k)</code></li><li>不覆盖添加数据 <code>putIfAbsent(k,v)</code></li><li>修改数据 <code>replace(k,v)</code></li><li>获取所有key值 <code>keySet()</code></li><li>获得所有的value值 <code>values()</code></li></ol><h4 id="hashtable"><code>HashTable</code></h4><ol type="1"><li><code>Table</code>和<code>Map</code>的实现方式不一样；继承的父类不一样，而且<code>Map</code>的<code>(k,v)</code>都可以为空</li><li><code>Map</code>的数据定位是哈希算法，Table采用的就是<code>HashCode</code></li></ol><h4 id="迭代器">迭代器</h4><ol type="1"><li>遍历<code>hashmap</code>时，可以使用迭代器进行遍历，并且进行删除修改操作</li></ol><h4 id="问题总结">问题总结</h4><ol type="1"><li><code>print</code>数组的时候，直接输出数组得到的是内存地址，可以将其转换为字符串再进行<code>print</code></li></ol><h3 id="io">IO</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path);</span><br><span class="line"><span class="comment">//判断是否是文件</span></span><br><span class="line">file.isFile();</span><br><span class="line"><span class="comment">//创建多级文件目录</span></span><br><span class="line">file.mkdirs();</span><br><span class="line"><span class="comment">//创建新的文件夹</span></span><br><span class="line">file.createNewFile();</span><br></pre></td></tr></table></figure><ol type="1"><li><code>java</code>中对于文件可以自动生成</li><li>缓冲流、字符流、序列化</li></ol><h3 id="线程">线程</h3><ol type="1"><li><p>编译过程 <code>javac</code> 指令，生成字节码class</p></li><li><p>Java程序在运行的时候默认产生一个进程，这个进程会有一个主线程，代码都在主线程中执行</p></li><li><p>创建线程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TODO 创建线程</span></span><br><span class="line"><span class="type">MyTread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTread</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//TODO 启动线程</span></span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure></li><li><p>并发：多线程之间彼此独立，互不影响</p></li><li><p>串行：多个线程连接成线，顺序执行</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Tread t1 = <span class="keyword">new</span> <span class="built_in">Tread</span>();</span><br><span class="line">Tread t2 = <span class="keyword">new</span> <span class="built_in">Tread</span>();</span><br><span class="line"><span class="comment">//并发</span></span><br><span class="line">t1.<span class="built_in">start</span>();</span><br><span class="line">t2.<span class="built_in">start</span>();</span><br><span class="line"><span class="comment">//串行</span></span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure></li><li><p>休眠</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread.slppe(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure></li><li><p>快速传递逻辑</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">T</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;逻辑传递&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">T.start()；</span><br></pre></td></tr></table></figure></li><li><p>线程池，就是线程对象的容器，根据需求在启动时可以创建一个或者多个线程对象，Java中常见的线程池包括4种</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TODO 固定数量线程池</span></span><br><span class="line"><span class="comment">//executorService是线程服务对象</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据需求动态创建线程</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line"><span class="comment">//单一线程，隐含线程顺序</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line"><span class="comment">//定时调度线程，可以自定义调度时间</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><ol start="9" type="1"><li><code>synchronized</code>同步关键字，多个线程访问同步方法的时候，只能一个一个访问，同步操作；修饰代码块，使得代码块成为同步代码块。</li><li><code>synchronized</code>具有原子性、可见性和有序性</li><li><figure><imgsrc="https://pic3.zhimg.com/80/v2-92f473a0d68aaf40002ebb774c015d16_720w.webp#pic_cent"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure></li><li>同步理解如下，对于一个对象<code>x=0</code>，线程A第一次访问时，由于本地内存中没有<code>x</code>，需要将其从主内存缓存到本地内存A中，进行更改<code>x=1</code>,并将其放回到主内存中；线程B第一次访问则将<code>x=1</code>读入本地内容B中，并修改为<code>x=2</code>然后放回主内存中。线程A<code>第二次访问x</code>时，由于本地内存A中存在，则会直接是使用本地内存中<code>x=1</code>，因此会出现内存不可见的问题。</li><li><code>wait()</code>需要等待其他进程释放资源之后，线程才能够继续进行，属于被迫性的阻塞</li><li><code>sleep()</code> 线程自动的休眠，主动性的阻塞</li><li><code>wait()</code>Object类中的成员方法，因此每一个对象都会有wait方法；必须在同步代码块中才能使用；如果执行<code>wait()</code>方法，其他线程可以执行当前的同步操作</li><li><code>sleep()</code>Thread类中的静态方法，在任意情况下都可以使用，其他线程不能执行当前的同步操作。</li><li><code>java</code>对每一个线程创建一个栈内存，但是对于每一个对象，在堆中开辟新的空间。因此，在多个线程并发执行的时候，修改共享内存中对象的属性，会导致数据冲突问题。</li></ol></li></ol><h3 id="反射">反射</h3><ol type="1"><li>Java反射就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；并且能改变它的属性</li></ol><h3 id="结语">结语</h3><p>​由于时间仓促，短暂学习后在读博和工作之间举棋不定，后经深思熟虑，决定专攻学术研究，因此<code>Java</code>语法暂时告一段落。因此本篇难免显得虎头蛇尾，若有机会，小子定会补全（抱拳）</p>]]></content>
    
    
    <summary type="html">记录计算机基础技能</summary>
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
    <category term="CS" scheme="http://example.com/tags/CS/"/>
    
  </entry>
  
  <entry>
    <title>PS-GAN</title>
    <link href="http://example.com/2023/12/12/PS-GAN/"/>
    <id>http://example.com/2023/12/12/PS-GAN/</id>
    <published>2023-12-12T11:57:08.000Z</published>
    <updated>2023-12-12T14:39:03.223Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>Title：<code>Perceptual-Sensitive GAN for Generating Adversarial Patches</code></p><p>Subject： <code>AAAI-19</code></p><p>Link：[<ahref="https://ojs.aaai.org/index.php/AAAI/article/view/3893">Paper</a>]</p><p>Keyword：<code>Adversarial Patches</code>、<code>GAN</code>、<code>Attention</code>、</p><h3 id="动机motivation">动机（Motivation）</h3><p>​对抗补丁<code>（Adversarial Patches）</code>对于网络具有一定的攻击性，但是视觉上不够自然，并且对抗补丁忽略了被攻击模型的感知敏感性。</p><p>​本文提出<code>PS-GAN</code>，同时增强对抗补丁的视觉保真度和攻击能力。主要是通过<code>patch-to-patch translation</code> 和<code>attention mechanism</code>来产生更自然、更具攻击性的对抗补丁。</p><h3 id="方法method">方法（Method）</h3><figure><img src="https://z1.ax1x.com/2023/12/12/pifEI0J.md.png#pic_center"alt="pifEI0J.md.png" /><figcaption aria-hidden="true">pifEI0J.md.png</figcaption></figure><ol type="1"><li>对于<code>Traffic Sign</code> <spanclass="math display">\[x\]</span>，通过<code>Attention Model</code><span class="math inline">\(M\)</span> 获得 <spanclass="math display">\[x\]</span> 中最具感知敏感性的位置<spanclass="math inline">\(M(x)\)</span>，该位置对于攻击更加敏感。</li><li>对于<code>Seed Patch</code> <spanclass="math inline">\(\delta\)</span> , 通过<code>Generator</code> <spanclass="math inline">\(G\)</span> 得到对抗补丁 <spanclass="math inline">\(G(\delta)\)</span></li><li>将 <span class="math inline">\(G(\delta)\)</span> 应用于 <spanclass="math inline">\(M(x)\)</span>，得到<code>Fake Traffic Sign</code><span class="math inline">\(\tilde{x}\)</span>, 将其输入<code>Target Model</code> <span class="math inline">\(F\)</span>和<code>Discriminator</code> <span class="math inline">\(D\)</span>,得到 <code>loss</code> 后进行梯度对抗攻击迭代模型参数</li></ol><p>其中<code>Attention Model</code> 使用 <code>GradCAM</code>，<spanclass="math inline">\(loss\)</span> 如下：</p><figure><imgsrc="https://z1.ax1x.com/2023/12/12/pifV9AA.png#pic_centepic_center"alt="pifV9AA.png" /><figcaption aria-hidden="true">pifV9AA.png</figcaption></figure><h3 id="结果result">结果（Result）</h3><p><strong>Patches 可视化结果</strong></p><figure><img src="https://z1.ax1x.com/2023/12/12/pifE6kn.md.png#pic_center"alt="pifE6kn.md.png" /><figcaption aria-hidden="true">pifE6kn.md.png</figcaption></figure><p><strong>攻击结果</strong></p><figure><img src="https://z1.ax1x.com/2023/12/12/pifA0aR.md.png#pic_cente"alt="pifA0aR.md.png" /><figcaption aria-hidden="true">pifA0aR.md.png</figcaption></figure><h3 id="总结conclusion">总结（Conclusion）</h3><ol type="1"><li>使用GradCAM 获得攻击敏感位置，并将Patches应用，可以提高攻击强度</li><li>通过 GAN 生成受约束的 Patches，将Patches变得更加自然，具有一定语义信息</li><li>未解决Patches 与 图像上下文不相容的问题，如果将 <spanclass="math inline">\(M(x)\)</span>作为<code>Seed Patch</code> <spanclass="math inline">\(\delta\)</span> ，最后生成Patches，Patches在视觉上更不可被人察觉。</li><li>本文尚未提供代码，因此更多细节不必深究</li></ol>]]></content>
    
    
    <summary type="html">关于生成式对抗样本的论文阅读</summary>
    
    
    
    <category term="Adversarial attack" scheme="http://example.com/categories/Adversarial-attack/"/>
    
    
    <category term="PaperNotes" scheme="http://example.com/tags/PaperNotes/"/>
    
  </entry>
  
  <entry>
    <title>从零搭建博客-Hexo</title>
    <link href="http://example.com/2023/11/25/Hexo/"/>
    <id>http://example.com/2023/11/25/Hexo/</id>
    <published>2023-11-25T07:39:40.000Z</published>
    <updated>2023-12-12T13:59:24.679Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>求学以来，零零散散的记录了一些问题，也形成了一些笔记，但是从未有过管理自己的博客的想法。归根结底，到底还是由于平台太多，自己太懒，并不像多平台发布，只想着取悦自己。因此，我搭建了一个专属自己的平台，随性发布一些内容。</p><p>选择<code>Hexo+GitHub</code>搭建博客，是因为本人现阶段并不打算租服务器或者在这上面花费太多的💴，因此选择这个组合来搭建博客</p><p>为了美化博客，最简单的方式就是使用<code>butterfly</code>等现有的主题，而关于如何使用<code>Node.js、GitHub、Hexo、Butterfly</code>搭建、美化，网络上有太多太多行之有效的教程，多出一份也毫无意义。因此，本人在此专门从小白角度，以身试法，总结一下自己遇到的问题</p><h3 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h3><ol><li><p>博客搭建初期，使用<code>Github</code>的进行<code>ssh key</code>连接过程，如果报错，很大程度上是网络问题，需要不断尝试 <code>打开代理-切换代理-关闭代理</code>等多种方法，或者是稍后访问。</p></li><li><p>基于<code>Hexo</code>的博客搭建常见命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo n page <span class="string">&quot;分类&quot;</span>  <span class="comment"># 新建页面</span></span><br><span class="line"></span><br><span class="line">hexo new <span class="string">&quot;My Blot&quot;</span>  <span class="comment"># 新建博客，注意冒号是必须带上的,会在source文件夹中出现 My Blot.md文件</span></span><br><span class="line"></span><br><span class="line">hexo g  <span class="comment"># 为md文件生成网页资源</span></span><br><span class="line"></span><br><span class="line">hexo d  <span class="comment"># 将网页资源推送到页面，也就是基于Github 搭建的页面</span></span><br><span class="line"></span><br><span class="line">hexo c  <span class="comment"># 清除所有已经生成的网页资源</span></span><br><span class="line"></span><br><span class="line">hexo s  <span class="comment"># 在本机上查看网页资源 （hostlocal：4000）端口号可能不一样 </span></span><br></pre></td></tr></table></figure></li></ol><h3 id="博客美化"><a href="#博客美化" class="headerlink" title="博客美化"></a>博客美化</h3><ol><li>本文接下来全部基于<code>butterfly</code></li><li><code>yml</code>打开时，尽量不要用<code>记事本</code>，因为<code>yml</code>中格式要求十分严格，<code>：</code>后面必须有一个<code>空格</code>，使用<code>记事本</code>容易破坏原有结构而导致报错</li><li><strong>子页面的生成</strong></li></ol><p>​<code>Butterfly</code>中提到，子页面也是普通页面，因此可以按照普通页面的生成方式进行生成。并且在示例中说明了如何添加“分类”、“标签”、“照片”等多个子页面。</p><p>​但是，本人遇到的问题如下：</p><img src="https://z1.ax1x.com/2023/11/25/pi0kDOg.png" alt="pi0kDOg.png" style="zoom:50%;" /><p>此情况一般是子页面缺失，需要新建子页面，子页面文件需要在主页面文件夹下，具体文件结构如下图：</p><img src="https://z1.ax1x.com/2023/11/25/pi0khlT.png#pic_center" alt="pi0khlT.png"  /><p><img src="https://z1.ax1x.com/2023/11/25/pi0kfpV.png#pic_center" alt="pi0kfpV.png"></p><p>其中<code>Gallery</code>文件夹包括<code>index.md</code>，以及所属的三个子页面文件夹<code>girls、scenry、wallpaper</code>，必须按照这个顺序，才能使得子页面有效。</p><ol start="4"><li><code>Butterfly</code>中画廊的应用</li></ol><p>说明文档中给出了代码示例，只要将下面代码放入<code>Gallery</code>主页面的<code>index.md</code>文件中，该页面下将会出现三个选项，这时候我们需要创建三个<code>子页面</code></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span><br><span class="line">&#123;% galleryGroup &#x27;壁纸&#x27; &#x27;也许，勇士每天面对的，都是星辰大海&#x27; &#x27;/Gallery/wallpaper&#x27; https://z1.ax1x.com/2023/11/25/piwvNvR.png %&#125;</span><br><span class="line">&#123;% galleryGroup &#x27;绝色&#x27; &#x27;如果你认为她是美的，那她便是极美的&#x27; &#x27;/Gallery/girls&#x27; https://z1.ax1x.com/2023/11/25/piwvY8J.png %&#125;</span><br><span class="line">&#123;% galleryGroup &#x27;风景&#x27; &#x27;人生在意的不是旅途终点，而是沿途的风景&#x27; &#x27;/Gallery/scenry&#x27; https://z1.ax1x.com/2023/11/25/piwvr5D.png %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>并且将下面代码放入<code>子页面</code>的<code>index.md</code>,便可以实现示例中的操作</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">![piwviHf.png](https://z1.ax1x.com/2023/11/25/piwviHf.png)</span><br><span class="line">![piwvJC4.md.png](https://z1.ax1x.com/2023/11/25/piwvJC4.md.png)</span><br><span class="line">![piwvY8J.png](https://z1.ax1x.com/2023/11/25/piwvY8J.png)</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>图床</li></ol><p>将图片放至线上，在<code>md</code>文件中调用时直接使用<code>html</code>调用，可以节省本地的空间</p><h3 id="博客书写"><a href="#博客书写" class="headerlink" title="博客书写"></a>博客书写</h3><p>对于初学者，使用<code>Typora</code>或者<code>vscode</code>进行markdown文件的撰写都可以，但是语法需要多家联系</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>关于<code>Hexo+butterfly</code>的博客搭建就到此结束，希望各位初学者能够跟随更加详细的博客，搭建出自己平台，当然，如果遇到一些 <strong>“这么简单我竟然没搞定”</strong> 的问题，也欢迎留言联系博主，让后续的学者少挠头！</p>]]></content>
    
    
    <summary type="html">记录博主从零搭建博客的一些问题、解决方案以及体会</summary>
    
    
    
    <category term="Hexo" scheme="http://example.com/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="http://example.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2023/11/24/hello-world/"/>
    <id>http://example.com/2023/11/24/hello-world/</id>
    <published>2023-11-24T10:04:23.510Z</published>
    <updated>2023-12-12T13:46:04.342Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h3 id="Code-Test"><a href="#Code-Test" class="headerlink" title="Code Test"></a>Code Test</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hello, my zone!&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="Image-test"><a href="#Image-test" class="headerlink" title="Image test"></a>Image test</h3><p><a href="https://imgse.com/i/piwviHf"><img src="https://z1.ax1x.com/2023/11/25/piwviHf.md.png" alt="piwviHf.md.png"></a></p>]]></content>
    
    
    <summary type="html">我出生了</summary>
    
    
    
    <category term="Hexo" scheme="http://example.com/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="http://example.com/tags/Hexo/"/>
    
  </entry>
  
</feed>
